# server.py
from typing import List,Dict, Any
from mcp.server.fastmcp import FastMCP
from openai import OpenAI
import os
from dotenv import load_dotenv
from service.reasoning import reasoning_agent
from service.places import chat_with_places_assistant
from service.services import generate_summary, perform_general_query, realtime_web_search
from service.gmail import format_search_results, gmail_draft_tool, gmail_get_tool, gmail_search_tool, gmail_send_tool
from langchain_google_community.gmail.search import Resource
from service.schedular import scheduler
# Load environment variables from .env file
load_dotenv()

# Create an MCP server instance named "Demo"
host=os.getenv("MCP_HOST", "0.0.0.0")
port=os.getenv("MCP_PORT", 8000)
# Provide host and port during instantiation

mcp = FastMCP("Demo", host=host, port=port)
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# Initialize OpenAI client
client = OpenAI(api_key=OPENAI_API_KEY)


@mcp.tool()
def Insight_scope(user_query: str) -> str:
    """
    InsightScope: An intelligent real-time web analysis agent.

    This tool performs dynamic, real-time web research powered by GPT-4o with browsing capabilities.
    It extracts and summarizes the most relevant, up-to-date information from trusted sources,
    including news, websites, documentation, and user reviews.

    Key Features:
    - Context-aware web search tailored to the user's query.
    - Real-time data extraction from authoritative sites.
    - Summarized insights with clickable source links.
    - Useful for market research, trend analysis, product scouting, or verifying recent developments.

    Input:
    - user_query (str): A natural-language query or topic of interest.

    Output:
    - A concise, informative summary with real-time findings and embedded links.

    Example Use Case:
    insight_scope("Latest updates on Apple's Vision Pro release")
    """
    return realtime_web_search(user_query)



@mcp.tool()
def Quickclarity(user_query: str) -> str:
    """
    QuickClarity: A fast, general-purpose assistant for instant answers.

    This tool uses a lightweight language model (e.g., GPT-3.5-Turbo) to quickly respond to everyday questions,
    explanations, and task prompts. It delivers fast, to-the-point answers suitable for general use where speed
    and clarity matter more than deep contextual analysis.

    Key Features:
    - Fast response time using an efficient model
    - Ideal for simple questions, clarifications, definitions, rewrites, and logic tasks
    - Minimal setup, low overhead—great for casual or utility agents in workflows

    Input:
    - user_query (str): A natural language prompt or question

    Output:
    - A concise, relevant answer generated by the assistant

    Example Use Case:
    quickclarity("What are the benefits of intermittent fasting?")
    """
    return perform_general_query(user_query)


@mcp.tool()
def Corebrief(long_text: str):
    """
    CoreBrief: A professional-grade summarization agent.

    This tool condenses long-form content—such as articles, reports, or documents—into concise, engaging summaries,
    preserving essential information, tone, and context. Ideal for professionals, analysts, and knowledge workers
    who need to digest complex material quickly.

    Key Features:
    - Extracts core ideas and removes fluff or repetition
    - Maintains original intent and logical flow
    - Suitable for emails, research papers, policy docs, meeting transcripts, and more
    - Delivers polished output that reads naturally

    Input:
    - long_text (str): The full text content to be summarized (e.g., multi-paragraph article or pasted text).

    Output:
    - A high-quality, human-readable summary that reflects the core message.

    Example Use Case:
    corebrief(open("weekly_report.txt").read())
    """
    return generate_summary(long_text)

@mcp.add_tool
def Geo_whisper(user_query: str) -> str:
    """
    GeoWhisper: A conversational location intelligence agent.

    This tool taps into location services (e.g., Google Places API) to retrieve accurate, real-time information 
    about places, businesses, landmarks, or services based on user queries.

    Key Features:
    - Place search using natural language (e.g., "Best cafes near me", "Hotels in Manali with Wi-Fi")
    - Returns structured details like address, ratings, hours, and contact info
    - Great for travel planning, local exploration, or service recommendations

    Input:
    - user_query (str): A location-related question or keyword phrase (e.g., "24/7 pharmacy in Delhi").

    Output:
    - A summarized, conversational result listing matching places with key details.

    Example Use Case:
    geo_whisper("Vegan restaurants near Juhu Beach")
    """
    return chat_with_places_assistant(user_query,client)

@mcp.add_tool
async def Reasoning_agent(user_query: str) -> str:
    """
    Reasoning Agent: An advanced, context-aware reasoning and research assistant.

    This tool is designed to handle complex, open-ended, or multifaceted queries by combining
    multiple research and reasoning strategies into a single coherent response. It can perform
    real-time web searches, query specialized knowledge bases, retrieve domain-specific documents,
    and synthesize findings into a structured, well-supported answer.

    Capabilities:
    - Multi-source research via web search, retrieval-augmented generation (RAG), and curated datasets
    - Intelligent information synthesis that merges factual data, expert analysis, and context-specific insights
    - Context adaptation to tailor responses based on query scope, intent, and complexity
    - Support for comparative analysis, historical trends, and multi-perspective evaluation
    - Fact-checking and credibility assessment from diverse, reliable sources

    Ideal For:
    - In-depth research tasks and exploratory analysis
    - Investigating emerging trends, technical developments, or policy shifts
    - Fact verification and cross-referencing information from multiple viewpoints
    - Strategic decision support where clarity, accuracy, and context are critical

    Input:
    - user_query (str): A specific or open-ended question/topic requiring thorough investigation.

    Output:
    - A well-rounded, evidence-backed response synthesizing insights from multiple data streams,
      including a clearly stated final answer and, if applicable, a supporting research summary.

    Example:
    reasoning_agent("What are the most promising applications of quantum computing in cybersecurity?")
    """
    response = await reasoning_agent.process_request(query=user_query)
    print("[DEBUG] Reasoning Agent Response:", response)

    if not response or "result" not in response:
        return "No answer found."

    result = response["result"]

    final_answer = result.get("final_answer", "")
    research_summary = result.get("content", "")

    if research_summary and final_answer:
        return f"RESEARCH SUMMARY:\n{research_summary}\n\nFINAL ANSWER:\n{final_answer}"
    elif final_answer:
        return f"FINAL ANSWER:\n{final_answer}"
    elif research_summary:
        return f"RESEARCH SUMMARY:\n{research_summary}"
    else:
        return "No detailed answer available."


@mcp.add_tool
def gmail_send(to: str, subject: str, message: str, cc: str = None, bcc: str = None) -> dict:
    """
    Send an email using Gmail.

    Args:
        to (str): Recipient email address.
        subject (str): Subject line.
        message (str): Email body content.
        cc (str, optional): CC recipients.
        bcc (str, optional): BCC recipients.

    Returns:
        dict: Status + Gmail API response
    """
    payload = {
        "to": [to],
        "subject": subject,
        "message": message,
        "cc": [cc] if cc else None,
        "bcc": [bcc] if bcc else None,
    }
    result = gmail_send_tool.invoke(payload)
    return format_search_results(str(result))


@mcp.add_tool
def gmail_draft(to: str, subject: str, message: str, cc: str = None, bcc: str = None) -> dict:
    """
    Create a Gmail draft.
    """
    payload = {
        "to": [to],
        "subject": subject,
        "message": message,
        "cc": [cc] if cc else None,
        "bcc": [bcc] if bcc else None,
    }
    result = gmail_draft_tool.invoke(payload)
    return format_search_results(str(result))


@mcp.add_tool
def gmail_search(query: str, max_results: int = 10, resource: str = "messages") -> dict:
    """
    Search Gmail messages or threads.

    Args:
        query (str): Gmail search string.
        max_results (int): Max results (default 10).
        resource (str): 'messages' or 'threads'.

    Returns:
        dict: Search results with metadata.
    """
    payload = {
        "query": query,
        "max_results": max_results,
        "resource": Resource.MESSAGES if resource == "messages" else Resource.THREADS
    }
    result = gmail_search_tool.invoke(payload)
    return format_search_results(str(result))

@mcp.tool()
def schedule_meeting(date: str, start_time: str, end_time: str, attendee_email: str) -> Dict[str, Any]:
    """
    Schedule a meeting in Google Calendar.

    Input
    - date (str): The date of the meeting (format: YYYY-MM-DD).
    - start_time (str): The start time of the meeting (format: HH:MM).
    - end_time (str): The end time of the meeting (format: HH:MM).
    - attendee_email (str): The email address of the meeting attendee.

    """
    response = scheduler.schedule_meeting(date, start_time, end_time, attendee_email)
    return response


# @mcp.tool()
# def finish_meeting(event_id: str) -> Dict[str, Any]:
#     """Finish (delete) a scheduled meeting by event ID."""
#     response = scheduler.finish_meeting(event_id)
#     return response


@mcp.tool()
def list_meetings() -> List[Dict[str, Any]]:
    """List the next 10 upcoming meetings."""
    response = scheduler.list_meetings()
    return response

# Run the server for local development or testing
if __name__ == "__main__":
    mcp.run(transport="sse")

